{
  "title": "Complete Guide to Recursion Patterns - From Basic to Advanced",
  "subtitle": "Master all recursion patterns with visualizations, templates, and LeetCode examples",
  "patterns": [
    {
      "id": 1,
      "title": "Basic Recursion (Foundation)",
      "icon": "ðŸ”¹",
      "description": "These teach how recursion flows (base case + recursive case). Focus: printing, factorial, sum, Fibonacci, etc.",
      "concepts": [
        "Print numbers 1 â†’ N or N â†’ 1",
        "Factorial of N",
        "Sum of first N numbers",
        "Fibonacci number",
        "Power of a number (a^n)",
        "Reverse a string / array recursively"
      ],
      "java_template": "// Basic Recursion Template\npublic class BasicRecursion {\n    // Template for linear recursion\n    public static int linearRecursion(int n) {\n        // Base case\n        if (n <= 0) return 0; // or 1 for factorial\n\n        // Recursive case\n        return n + linearRecursion(n - 1);\n    }\n\n    // Fibonacci with tree recursion\n    public static int fibonacci(int n) {\n        if (n <= 1) return n;\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n\n    // Power calculation\n    public static int power(int base, int exp) {\n        if (exp == 0) return 1;\n        return base * power(base, exp - 1);\n    }\n}",
      "leetcode_problems": [
        {
          "number": 509,
          "title": "Fibonacci Number",
          "difficulty": "Easy"
        },
        {
          "number": 50,
          "title": "Pow(x, n)",
          "difficulty": "Medium"
        },
        {
          "number": 344,
          "title": "Reverse String",
          "difficulty": "Easy"
        }
      ],
      "complexity": "Time: O(n) for linear, O(2^n) for tree recursion | Space: O(n) call stack"
    },
    {
      "id": 2,
      "title": "Recursion with Arrays / Strings",
      "icon": "ðŸ”¹",
      "description": "Learning to pass index, reduce input, and build result.",
      "concepts": [
        "Print array elements recursively",
        "Reverse array/string recursively",
        "Palindrome check",
        "Find element in array",
        "Sum of array",
        "Maximum element in array",
        "Substring generation"
      ],
      "java_template": "// Array/String Recursion Template\npublic class ArrayStringRecursion {\n    // Process array with index\n    public static void printArray(int[] arr, int index) {\n        if (index >= arr.length) return;\n        System.out.print(arr[index] + \" \");\n        printArray(arr, index + 1);\n    }\n\n    // Check palindrome recursively\n    public static boolean isPalindrome(String s, int left, int right) {\n        if (left >= right) return true;\n        if (s.charAt(left) != s.charAt(right)) return false;\n        return isPalindrome(s, left + 1, right - 1);\n    }\n\n    // Find maximum in array\n    public static int findMax(int[] arr, int index) {\n        if (index == arr.length - 1) return arr[index];\n        return Math.max(arr[index], findMax(arr, index + 1));\n    }\n}",
      "leetcode_problems": [
        {
          "number": 125,
          "title": "Valid Palindrome",
          "difficulty": "Easy"
        },
        {
          "number": 344,
          "title": "Reverse String",
          "difficulty": "Easy"
        },
        {
          "number": 28,
          "title": "Find Index of First Occurrence",
          "difficulty": "Easy"
        }
      ],
      "complexity": "Time: O(n) | Space: O(n) for recursion depth"
    },
    {
      "id": 3,
      "title": "Subset / Subsequence Pattern",
      "icon": "ðŸ”¹",
      "description": "Very common pattern for backtracking, DP, and combinations.",
      "concepts": [
        "Generate all subsequences of a string",
        "Generate subsets of an array",
        "Subset sum problem",
        "Count subsequences with given sum"
      ],
      "java_template": "// Subset/Subsequence Template\npublic class SubsetPattern {\n    public static void generateSubsets(int[] nums, int index, \n                                     List<Integer> current, List<List<Integer>> result) {\n        // Base case - add current subset\n        if (index == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        // Exclude current element\n        generateSubsets(nums, index + 1, current, result);\n\n        // Include current element\n        current.add(nums[index]);\n        generateSubsets(nums, index + 1, current, result);\n        current.remove(current.size() - 1); // backtrack\n    }\n\n    // Subset sum check\n    public static boolean subsetSum(int[] arr, int index, int target) {\n        if (target == 0) return true;\n        if (index >= arr.length || target < 0) return false;\n\n        return subsetSum(arr, index + 1, target) || \n               subsetSum(arr, index + 1, target - arr[index]);\n    }\n}",
      "leetcode_problems": [
        {
          "number": 78,
          "title": "Subsets",
          "difficulty": "Medium"
        },
        {
          "number": 90,
          "title": "Subsets II",
          "difficulty": "Medium"
        },
        {
          "number": 416,
          "title": "Partition Equal Subset Sum",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(2^n) | Space: O(n) for recursion depth"
    },
    {
      "id": 4,
      "title": "Permutations Pattern",
      "icon": "ðŸ”¹",
      "description": "Order matters, unlike subsets.",
      "concepts": [
        "String/array permutations",
        "Distinct permutations (handling duplicates)",
        "Next permutation"
      ],
      "java_template": "// Permutations Template\npublic class PermutationPattern {\n    public static void generatePermutations(int[] nums, int index, \n                                          List<List<Integer>> result) {\n        // Base case\n        if (index == nums.length) {\n            List<Integer> perm = new ArrayList<>();\n            for (int num : nums) perm.add(num);\n            result.add(perm);\n            return;\n        }\n\n        for (int i = index; i < nums.length; i++) {\n            // Swap\n            swap(nums, index, i);\n            generatePermutations(nums, index + 1, result);\n            swap(nums, index, i); // backtrack\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // Handle duplicates\n    public static void permuteUnique(int[] nums, boolean[] used, \n                                   List<Integer> current, List<List<Integer>> result) {\n        if (current.size() == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) \n                continue;\n\n            used[i] = true;\n            current.add(nums[i]);\n            permuteUnique(nums, used, current, result);\n            current.remove(current.size() - 1);\n            used[i] = false;\n        }\n    }\n}",
      "leetcode_problems": [
        {
          "number": 46,
          "title": "Permutations",
          "difficulty": "Medium"
        },
        {
          "number": 47,
          "title": "Permutations II",
          "difficulty": "Medium"
        },
        {
          "number": 31,
          "title": "Next Permutation",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(n! * n) | Space: O(n) for recursion depth"
    },
    {
      "id": 5,
      "title": "Combinations Pattern",
      "icon": "ðŸ”¹",
      "description": "Choose k elements out of n.",
      "concepts": [
        "Print all combinations of size k",
        "Combination sum problems",
        "Combinations with constraints"
      ],
      "java_template": "// Combinations Template\npublic class CombinationPattern {\n    public static void generateCombinations(int[] nums, int start, int k, \n                                          List<Integer> current, List<List<Integer>> result) {\n        // Base case - found k elements\n        if (current.size() == k) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = start; i < nums.length; i++) {\n            current.add(nums[i]);\n            generateCombinations(nums, i + 1, k, current, result);\n            current.remove(current.size() - 1); // backtrack\n        }\n    }\n\n    // Combination Sum (can reuse elements)\n    public static void combinationSum(int[] candidates, int target, int start,\n                                    List<Integer> current, List<List<Integer>> result) {\n        if (target == 0) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = start; i < candidates.length; i++) {\n            if (candidates[i] <= target) {\n                current.add(candidates[i]);\n                combinationSum(candidates, target - candidates[i], i, current, result);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n}",
      "leetcode_problems": [
        {
          "number": 39,
          "title": "Combination Sum",
          "difficulty": "Medium"
        },
        {
          "number": 40,
          "title": "Combination Sum II",
          "difficulty": "Medium"
        },
        {
          "number": 77,
          "title": "Combinations",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(2^n) to O(n^k) | Space: O(k) for recursion depth"
    },
    {
      "id": 6,
      "title": "Partitioning / Palindrome Partitioning",
      "icon": "ðŸ”¹",
      "description": "Divide into valid groups.",
      "concepts": [
        "Partition array/string into k groups",
        "Palindrome partitioning",
        "Word break problem"
      ],
      "java_template": "// Partitioning Template\npublic class PartitioningPattern {\n    public static void palindromePartition(String s, int start, \n                                         List<String> current, List<List<String>> result) {\n        // Base case\n        if (start == s.length()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                palindromePartition(s, end + 1, current, result);\n                current.remove(current.size() - 1); // backtrack\n            }\n        }\n    }\n\n    private static boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    // Word Break\n    public static boolean wordBreak(String s, Set<String> wordDict, int start) {\n        if (start == s.length()) return true;\n\n        for (int end = start + 1; end <= s.length(); end++) {\n            String word = s.substring(start, end);\n            if (wordDict.contains(word) && wordBreak(s, wordDict, end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 131,
          "title": "Palindrome Partitioning",
          "difficulty": "Medium"
        },
        {
          "number": 139,
          "title": "Word Break",
          "difficulty": "Medium"
        },
        {
          "number": 698,
          "title": "Partition to K Equal Sum Subsets",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(2^n) | Space: O(n) for recursion depth"
    },
    {
      "id": 7,
      "title": "Recursion on Grids / Matrix",
      "icon": "ðŸ”¹",
      "description": "DFS style problems (backtracking + recursion).",
      "concepts": [
        "Count paths in a grid",
        "Print all paths",
        "Rat in a maze",
        "Word search",
        "Flood fill"
      ],
      "java_template": "// Grid/Matrix Recursion Template\npublic class GridRecursion {\n    private static int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n\n    // Count paths in grid\n    public static int countPaths(int[][] grid, int row, int col, \n                               int targetRow, int targetCol) {\n        if (row == targetRow && col == targetCol) return 1;\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length\n            || grid[row][col] == 1) return 0; // 1 represents obstacle\n\n        int paths = 0;\n        for (int[] dir : directions) {\n            paths += countPaths(grid, row + dir[0], col + dir[1], targetRow, targetCol);\n        }\n        return paths;\n    }\n\n    // Word Search in grid\n    public static boolean wordSearch(char[][] board, String word, int index, \n                                   int row, int col, boolean[][] visited) {\n        if (index == word.length()) return true;\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length\n            || visited[row][col] || board[row][col] != word.charAt(index)) {\n            return false;\n        }\n\n        visited[row][col] = true;\n        boolean found = false;\n\n        for (int[] dir : directions) {\n            if (wordSearch(board, word, index + 1, row + dir[0], col + dir[1], visited)) {\n                found = true;\n                break;\n            }\n        }\n\n        visited[row][col] = false; // backtrack\n        return found;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 79,
          "title": "Word Search",
          "difficulty": "Medium"
        },
        {
          "number": 200,
          "title": "Number of Islands",
          "difficulty": "Medium"
        },
        {
          "number": 733,
          "title": "Flood Fill",
          "difficulty": "Easy"
        }
      ],
      "complexity": "Time: O(4^(m*n)) worst case | Space: O(m*n) for recursion and visited array"
    },
    {
      "id": 8,
      "title": "Recursion with Decision Making (Choices)",
      "icon": "ðŸ”¹",
      "description": "Classic backtracking pattern.",
      "concepts": [
        "N-Queens problem",
        "Sudoku solver",
        "Knight's tour",
        "Generate valid parentheses",
        "Binary tree path sums"
      ],
      "java_template": "// Decision Making Recursion Template\npublic class DecisionMakingRecursion {\n    // N-Queens\n    public static boolean solveNQueens(int[][] board, int col) {\n        int n = board.length;\n        if (col >= n) return true; // All queens placed\n\n        for (int row = 0; row < n; row++) {\n            if (isSafe(board, row, col)) {\n                board[row][col] = 1; // Place queen\n\n                if (solveNQueens(board, col + 1)) return true;\n\n                board[row][col] = 0; // Backtrack\n            }\n        }\n        return false;\n    }\n\n    private static boolean isSafe(int[][] board, int row, int col) {\n        int n = board.length;\n        // Check row, column, and diagonals\n        for (int i = 0; i < col; i++) {\n            if (board[row][i] == 1) return false;\n        }\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 1) return false;\n        }\n        for (int i = row, j = col; i < n && j >= 0; i++, j--) {\n            if (board[i][j] == 1) return false;\n        }\n        return true;\n    }\n\n    // Generate Valid Parentheses\n    public static void generateParentheses(int n, int open, int close, \n                                         String current, List<String> result) {\n        if (current.length() == 2 * n) {\n            result.add(current);\n            return;\n        }\n\n        if (open < n) {\n            generateParentheses(n, open + 1, close, current + \"(\", result);\n        }\n        if (close < open) {\n            generateParentheses(n, open, close + 1, current + \")\", result);\n        }\n    }\n}",
      "leetcode_problems": [
        {
          "number": 22,
          "title": "Generate Parentheses",
          "difficulty": "Medium"
        },
        {
          "number": 51,
          "title": "N-Queens",
          "difficulty": "Hard"
        },
        {
          "number": 37,
          "title": "Sudoku Solver",
          "difficulty": "Hard"
        }
      ],
      "complexity": "Time: O(n!) for N-Queens, O(4^n) for parentheses | Space: O(n) for recursion depth"
    },
    {
      "id": 9,
      "title": "Recursion + Binary Search / Divide & Conquer",
      "icon": "ðŸ”¹",
      "description": "Optimized recursion (logarithmic splits).",
      "concepts": [
        "Binary search",
        "Merge sort",
        "Quick sort",
        "Pow(x, n)",
        "Search in rotated sorted array"
      ],
      "java_template": "// Divide & Conquer Template\npublic class DivideConquerRecursion {\n    // Binary Search\n    public static int binarySearch(int[] arr, int target, int left, int right) {\n        if (left > right) return -1;\n\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n\n        if (arr[mid] > target) {\n            return binarySearch(arr, target, left, mid - 1);\n        } else {\n            return binarySearch(arr, target, mid + 1, right);\n        }\n    }\n\n    // Merge Sort\n    public static void mergeSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n\n            mergeSort(arr, left, mid);\n            mergeSort(arr, mid + 1, right);\n\n            merge(arr, left, mid, right);\n        }\n    }\n\n    private static void merge(int[] arr, int left, int mid, int right) {\n        int[] temp = new int[right - left + 1];\n        int i = left, j = mid + 1, k = 0;\n\n        while (i <= mid && j <= right) {\n            temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];\n        }\n        while (i <= mid) temp[k++] = arr[i++];\n        while (j <= right) temp[k++] = arr[j++];\n\n        System.arraycopy(temp, 0, arr, left, temp.length);\n    }\n\n    // Power calculation (optimized)\n    public static double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n\n        long longN = Math.abs((long) n);\n        double result = powHelper(x, longN);\n\n        return (n < 0) ? 1.0 / result : result;\n    }\n\n    private static double powHelper(double x, long n) {\n        if (n == 0) return 1.0;\n        if (n == 1) return x;\n\n        double half = powHelper(x, n / 2);\n        return (n % 2 == 0) ? half * half : half * half * x;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 50,
          "title": "Pow(x, n)",
          "difficulty": "Medium"
        },
        {
          "number": 33,
          "title": "Search in Rotated Sorted Array",
          "difficulty": "Medium"
        },
        {
          "number": 215,
          "title": "Kth Largest Element in Array",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(log n) for binary search, O(n log n) for merge sort | Space: O(log n) for recursion stack"
    },
    {
      "id": 10,
      "title": "Recursion in Trees",
      "icon": "ðŸ”¹",
      "description": "Most tree problems are recursive by nature.",
      "concepts": [
        "Preorder, Inorder, Postorder traversal",
        "Height of binary tree",
        "Diameter of tree",
        "Path sum",
        "Lowest common ancestor",
        "Serialize/Deserialize tree"
      ],
      "java_template": "// Tree Recursion Template\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic class TreeRecursion {\n    // Tree Traversals\n    public static void inorderTraversal(TreeNode root, List<Integer> result) {\n        if (root == null) return;\n\n        inorderTraversal(root.left, result);\n        result.add(root.val);\n        inorderTraversal(root.right, result);\n    }\n\n    // Height of tree\n    public static int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n\n    // Path Sum\n    public static boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) return false;\n\n        if (root.left == null && root.right == null) {\n            return root.val == targetSum;\n        }\n\n        return hasPathSum(root.left, targetSum - root.val) ||\n               hasPathSum(root.right, targetSum - root.val);\n    }\n\n    // Diameter of tree\n    private static int maxDiameter = 0;\n\n    public static int diameterOfBinaryTree(TreeNode root) {\n        maxDiameter = 0;\n        calculateHeight(root);\n        return maxDiameter;\n    }\n\n    private static int calculateHeight(TreeNode node) {\n        if (node == null) return 0;\n\n        int leftHeight = calculateHeight(node.left);\n        int rightHeight = calculateHeight(node.right);\n\n        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);\n\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 104,
          "title": "Maximum Depth of Binary Tree",
          "difficulty": "Easy"
        },
        {
          "number": 112,
          "title": "Path Sum",
          "difficulty": "Easy"
        },
        {
          "number": 543,
          "title": "Diameter of Binary Tree",
          "difficulty": "Easy"
        }
      ],
      "complexity": "Time: O(n) where n is number of nodes | Space: O(h) where h is height of tree"
    },
    {
      "id": 11,
      "title": "Recursion in Dynamic Programming (Top-Down Memoization)",
      "icon": "ðŸ”¹",
      "description": "Recursive + memoization.",
      "concepts": [
        "Fibonacci with memoization",
        "Climbing stairs",
        "Coin change",
        "Knapsack problem",
        "Longest common subsequence",
        "Matrix path problems"
      ],
      "java_template": "// Dynamic Programming with Recursion Template\npublic class DPRecursion {\n    // Fibonacci with memoization\n    public static int fibonacciMemo(int n, Map<Integer, Integer> memo) {\n        if (n <= 1) return n;\n        if (memo.containsKey(n)) return memo.get(n);\n\n        int result = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n        memo.put(n, result);\n        return result;\n    }\n\n    // Climbing Stairs\n    public static int climbStairs(int n, Map<Integer, Integer> memo) {\n        if (n <= 1) return 1;\n        if (memo.containsKey(n)) return memo.get(n);\n\n        int result = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\n        memo.put(n, result);\n        return result;\n    }\n\n    // Coin Change (minimum coins)\n    public static int coinChange(int[] coins, int amount, Map<Integer, Integer> memo) {\n        if (amount == 0) return 0;\n        if (amount < 0) return -1;\n        if (memo.containsKey(amount)) return memo.get(amount);\n\n        int minCoins = Integer.MAX_VALUE;\n        for (int coin : coins) {\n            int result = coinChange(coins, amount - coin, memo);\n            if (result >= 0) {\n                minCoins = Math.min(minCoins, result + 1);\n            }\n        }\n\n        int finalResult = (minCoins == Integer.MAX_VALUE) ? -1 : minCoins;\n        memo.put(amount, finalResult);\n        return finalResult;\n    }\n\n    // Longest Common Subsequence\n    public static int lcs(String text1, String text2, int i, int j, \n                         Map<String, Integer> memo) {\n        if (i >= text1.length() || j >= text2.length()) return 0;\n\n        String key = i + \",\" + j;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        int result;\n        if (text1.charAt(i) == text2.charAt(j)) {\n            result = 1 + lcs(text1, text2, i + 1, j + 1, memo);\n        } else {\n            result = Math.max(lcs(text1, text2, i + 1, j, memo),\n                            lcs(text1, text2, i, j + 1, memo));\n        }\n\n        memo.put(key, result);\n        return result;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 70,
          "title": "Climbing Stairs",
          "difficulty": "Easy"
        },
        {
          "number": 322,
          "title": "Coin Change",
          "difficulty": "Medium"
        },
        {
          "number": 1143,
          "title": "Longest Common Subsequence",
          "difficulty": "Medium"
        }
      ],
      "complexity": "Time: O(n) with memoization vs O(2^n) without | Space: O(n) for memo + recursion stack"
    },
    {
      "id": 12,
      "title": "Advanced Recursion / Backtracking",
      "icon": "ðŸ”¹",
      "description": "Complex problems requiring sophisticated recursive techniques.",
      "concepts": [
        "Word search in dictionary",
        "Regular expression matching",
        "Wildcard matching",
        "Crossword / puzzles",
        "Recursive DP on bitmask"
      ],
      "java_template": "// Advanced Recursion Template\npublic class AdvancedRecursion {\n    // Regular Expression Matching\n    public static boolean isMatch(String s, String p, int i, int j, \n                                Map<String, Boolean> memo) {\n        String key = i + \",\" + j;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        boolean result;\n        if (j >= p.length()) {\n            result = i >= s.length();\n        } else {\n            boolean firstMatch = i < s.length() && \n                               (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');\n\n            if (j + 1 < p.length() && p.charAt(j + 1) == '*') {\n                result = isMatch(s, p, i, j + 2, memo) || \n                        (firstMatch && isMatch(s, p, i + 1, j, memo));\n            } else {\n                result = firstMatch && isMatch(s, p, i + 1, j + 1, memo);\n            }\n        }\n\n        memo.put(key, result);\n        return result;\n    }\n\n    // Word Search II (Trie + Backtracking)\n    static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        String word = null;\n    }\n\n    public static List<String> findWords(char[][] board, String[] words) {\n        TrieNode root = buildTrie(words);\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfsWordSearch(board, i, j, root, result);\n            }\n        }\n        return result;\n    }\n\n    private static void dfsWordSearch(char[][] board, int row, int col, \n                                    TrieNode node, List<String> result) {\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) \n            return;\n\n        char c = board[row][col];\n        if (c == '#' || node.children[c - 'a'] == null) return;\n\n        node = node.children[c - 'a'];\n        if (node.word != null) {\n            result.add(node.word);\n            node.word = null; // Avoid duplicates\n        }\n\n        board[row][col] = '#'; // Mark as visited\n        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        for (int[] dir : directions) {\n            dfsWordSearch(board, row + dir[0], col + dir[1], node, result);\n        }\n        board[row][col] = c; // Backtrack\n    }\n\n    private static TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                if (node.children[c - 'a'] == null) {\n                    node.children[c - 'a'] = new TrieNode();\n                }\n                node = node.children[c - 'a'];\n            }\n            node.word = word;\n        }\n        return root;\n    }\n}",
      "leetcode_problems": [
        {
          "number": 44,
          "title": "Wildcard Matching",
          "difficulty": "Hard"
        },
        {
          "number": 212,
          "title": "Word Search II",
          "difficulty": "Hard"
        },
        {
          "number": 10,
          "title": "Regular Expression Matching",
          "difficulty": "Hard"
        }
      ],
      "complexity": "Time: Exponential in worst case, optimized with pruning | Space: O(n) for recursion + additional data structures"
    }
  ]
}